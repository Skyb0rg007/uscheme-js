{"version":3,"sources":["contexts/Interpreter.js","react-console-emulator/defs/styles/TerminalMessage.js","react-console-emulator/defs/types/TerminalMessage.js","react-console-emulator/TerminalMessage.jsx","react-console-emulator/utils/sendCursorToEnd.js","react-console-emulator/handlers/scrollHistory.js","react-console-emulator/utils/cleanArray.js","react-console-emulator/defs/styles/Terminal.js","react-console-emulator/defs/types/Terminal.js","react-console-emulator/Terminal.jsx","react-console-emulator/handlers/parseEOL.js","components/view/Repl.js","components/view/uscheme-mode.js","components/view/Editor.js","components/view/FileManager.js","App.js","interpreters/uscheme.js","index.js"],"names":["React","createContext","eval","str","console","log","reset","name","mode","autoCloseBrackets","PropTypes","node","object","string","bool","lineHeight","TerminalMessage","this","props","content","style","className","styles","message","defaults","sourceStyles","dangerMode","html","Component","inputElement","cursorStart","selectionStart","cursorEnd","selectionEnd","setTimeout","setSelectionRange","direction","options","dirtyArray","history","historyPosition","previousHistoryPosition","terminalInput","commandHistory","Array","from","filter","i","undefined","reverse","position","previousPosition","terminal","current","length","latest","first","next","value","sendCursorToEnd","minHeight","maxWidth","maxHeight","borderRadius","overflow","cursor","backgroundColor","backgroundSize","padding","height","fontSize","color","fontFamily","display","width","paddingTop","border","margin","flexGrow","background","outline","styleTypes","contentStyle","inputAreaStyle","promptLabelStyle","inputStyle","classNameTypes","contentClassName","inputAreaClassName","promptLabelClassName","inputClassName","optionTypes","autoFocus","disabled","disableOnProcess","ignoreCommandCase","noDefaults","noEchoBack","noHistory","noAutoScroll","noNewlineParsing","labelTypes","welcomeMessage","oneOfType","arrayOf","promptLabel","errorText","commandTypes","runCommand","func","isRequired","messageTypes","messageStyle","messageClassName","Terminal","focusTerminal","window","getSelection","type","focus","scrollToBottom","rootNode","terminalRoot","scrollTop","scrollHeight","showWelcomeMessage","msg","pushToStdout","stdout","state","push","isEcho","rawInput","pushToHistory","setState","getStdout","parsedStdout","currentLine","messageText","innerText","parsed","test","split","line","parseEOL","map","key","clearStdout","clearInput","processCommand","processing","echo","res","scrollHistory","toUpdate","handleInput","event","ctrlKey","keyCode","preventDefault","createRef","container","inputArea","input","ref","onClick","onKeyDown","autoComplete","Repl","forwardRef","_props","interp","useContext","InterpContext","terminalRef","useRef","useImperativeHandle","forEach","welcome","CodeMirror","defineMode","makeKeywords","obj","words","keywords","indentKeys","stateStack","indent","prev","pushStack","indentStack","binaryMatcher","RegExp","octalMatcher","hexMatcher","decimalMatcher","isBinaryNumber","stream","match","isOctalNumber","isDecimalNumber","backup","backUp","isHexNumber","startState","indentation","sExprComment","sExprQuote","token","sol","eatSpace","returnType","escaped","maybeEnd","peek","eatWhile","ch","eat","numTest","hasExactness","hasRadix","skipToEnd","letter","keyWord","indentTemp","column","propertyIsEnumerable","eol","popStack","closeBrackets","pairs","lineComment","defineMIME","Editor","onCtrlEnter","onEdit","useState","instance","setInstance","useEffect","keyMap","cm","toggleComment","addKeyMap","theme","smartIndent","lineNumbers","matchBrackets","onBeforeChange","_editor","_data","editorDidMount","editor","FileManager","usemap","onAddFile","onFileSelect","invalid","setInvalid","formRef","formSubmit","e","filename","has","Container","Row","Form","onSubmit","Col","Control","placeholder","isInvalid","Button","icon","faFolderPlus","ListGroup","file","Item","action","m","localStorage","getItem","Map","Object","entries","JSON","parse","URLSearchParams","location","search","get","setUsemap","setItem","stringify","fromEntries","replRef","currentFile","setCurrentFile","filemap","uscheme","make_interp","interpEval","setInterpEval","usefn","resetEval","newEval","useUschemeInterpreter","Fragment","Navbar","bg","expand","Brand","Nav","xs","set","Provider","x","ReactDOM","render","StrictMode","App","document","getElementById"],"mappings":"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","file":"static/js/main.83eec171.chunk.js","sourcesContent":["import React from 'react';\n\n// Language interface:\n//\n//\n// eval: string -> string\n//  Eval takes an input string and evaluates it.\n//  The returned string is considered to be the output, which is\n//  to be written to the terminal. stdout/stderr should be combined.\n//\n// resetEval: string -> string\n//  ResetEval creates a new environment and evaluates the input string in the new environment.\n//  Future calls to 'eval' should use this new environment.\n//\n// name: string\n//  The language name used in multiple locations\n//\n// mode: string\n//  The CodeMirror language mode to use.\n//  Choose something similar, or write your own.\n//\n// autoCloseBrackets: string\n//  String containing the brackets to be closed in the editor\n//  Ex. In uscheme, the single quote ' should not auto-close.\n\nexport default React.createContext({\n  eval: str => console.log(`Unable to call 'eval(\"${str}\")': Context not initialized`),\n  reset: str => console.log(`Unable to call 'reset(\"${str}\")': Context not initialized`),\n  name: '<unnamed>',\n  mode: '',\n  autoCloseBrackets: '()[]{}'\n});\n\n// export default React.createContext({\n  // eval: str => console.log(`Unable to eval(\"${str}\"): Interpreter context not initialized`),\n  // reset: str => console.log(`Unable to reset(\"${str}\"): Interpreter context not initialized`),\n  // name: '<unnamed>'\n// });\n\n","export default {\n  lineHeight: '21px'\n}\n","import PropTypes from 'prop-types'\n\nexport default {\n  content: PropTypes.node,\n  style: PropTypes.object,\n  className: PropTypes.string,\n  dangerMode: PropTypes.bool\n}\n","import React, { Component } from 'react'\nimport html from 'react-inner-html'\nimport defaults from 'defaults'\n\nimport types from './defs/types/TerminalMessage'\nimport sourceStyles from './defs/styles/TerminalMessage'\n\nexport default class TerminalMessage extends Component {\n  static propTypes = types\n\n  render () {\n    const { content, style, className } = this.props\n\n    const styles = {\n      message: defaults(style, sourceStyles)\n    }\n\n    return this.props.dangerMode\n      ? <div className={className} style={styles.message} {...html(content)}/>\n      : <div className={className} style={styles.message}>{content}</div>\n  }\n}\n","export default inputElement => {\n  if (inputElement) {\n    const cursorStart = inputElement.selectionStart\n    const cursorEnd = inputElement.selectionEnd\n\n    // Decouple execution for 2 ms (1 doesn't work for... Reasons) in order to properly send cursor to end\n    setTimeout(() => inputElement.setSelectionRange(cursorStart, cursorEnd), 10)\n  }\n}\n","/* eslint-disable */\nimport cleanArray from '../utils/cleanArray'\nimport sendCursorToEnd from '../utils/sendCursorToEnd'\n\n/**\n * Scrolls command history in a given direction\n * @param {String} direction Direction to scroll in ('up' or 'down')\n * @param {Object} options\n * @param {Array} options.history - Array of previous inputs from the user\n * @param {Number} options.historyPosition - Current position in the history\n * @param {Number} options.previousHistoryPosition - Previous position in the history\n * @param {React.Ref} options.terminalInput - Ref to the terminal input element\n */\nexport default (direction, options) => {\n  const { history, historyPosition, previousHistoryPosition, terminalInput } = options\n\n  // BUG: I have to duplicate sendCursorToEnd for each condition, because doing so in a catch-all manner doesn't seem to work at all\n\n  // Clean potential empty items and reverse order to ease position tracking\n  // (Reverse = starting from the newest first when going up and vice versa)\n  const commandHistory = cleanArray(history).reverse()\n  const position = historyPosition\n  const previousPosition = previousHistoryPosition\n  const terminal = terminalInput.current\n\n  if (commandHistory.length > 0) { // Only run if history is non-empty and in use\n    switch (direction) {\n      case 'up': {\n        // Declaring variables for these here to better clarify this block which can get pretty convoluted\n        const latest = commandHistory[0]\n        const first = commandHistory[commandHistory.length - 1]\n        const next = commandHistory[position + 1]\n\n        if (position === null) {\n          // If at no yet defined position, get most recent entry\n          terminal.value = latest\n          sendCursorToEnd(terminal)\n\n          return {\n            historyPosition: 0,\n            previousHistoryPosition: null\n          }\n        } else if (position + 1 === commandHistory.length) {\n          // If the first entry will be reached on this press, get it and decrement position by 1 to avoid confusing downscroll\n          // EXCEPT: If there is only 1 unit in the history, our previous position was actually null, not zero as defined above\n          // Hence why in one-unit histories the previous position has to be set to null, not 0\n          terminal.value = first\n          sendCursorToEnd(terminal)\n\n          return {\n            historyPosition: commandHistory.length - 1,\n            previousHistoryPosition: commandHistory.length === 1 ? null : commandHistory.length - 2\n          }\n        } else {\n          // Normal increment by one\n          terminal.value = next\n          sendCursorToEnd(terminal)\n\n          return {\n            historyPosition: position + 1,\n            previousHistoryPosition: position\n          }\n        }\n      }\n      case 'down': {\n        // Declaring variables for these here to better clarify this block which can get pretty convoluted\n        const latest = commandHistory[0]\n        const empty = ''\n        const next = commandHistory[position - 1]\n\n        if (position === null || !commandHistory[position]) {\n          // If at initial or out of range, clear (Unix-like behaviour)\n          terminal.value = empty\n          sendCursorToEnd(terminal)\n\n          return {\n            historyPosition: null,\n            previousHistoryPosition: null\n          }\n        } else if (position - 1 === -1) {\n          // Clear because user is either pressing up once and is now pressing down again, or is reaching the latest entry\n          if (previousPosition === null || (position === 0 && previousPosition === 1)) terminal.value = empty\n          else terminal.value = latest\n          sendCursorToEnd(terminal)\n\n          return {\n            historyPosition: null,\n            previousHistoryPosition: null\n          }\n        } else {\n          // Normal decrement by one\n          terminal.value = next\n          sendCursorToEnd(terminal)\n\n          return {\n            historyPosition: position - 1,\n            previousHistoryPosition: position\n          }\n        }\n      }\n    }\n  }\n}\n","/**\n * Workaround to clean an array from 'ghost items'.\n * @param {Array} dirtyArray\n */\nexport default function cleanArray (dirtyArray) {\n  const newArray = Array.from(dirtyArray)\n  return newArray.filter(i => i !== undefined)\n}\n","\nexport default {\n  container: {\n    minHeight: '300px',\n    maxWidth: '100%', // Fill parent before overflowing\n    maxHeight: '100%', // Fill parent before overflowing\n    borderRadius: '5px',\n    overflow: 'auto',\n    cursor: 'text',\n    backgroundColor: '#212121',\n    backgroundSize: 'cover'\n  },\n  content: {\n    padding: '20px',\n    height: '100%',\n    fontSize: '15px',\n    color: '#FFFFFF',\n    fontFamily: 'monospace'\n  },\n  inputArea: {\n    display: 'inline-flex',\n    width: '100%'\n  },\n  promptLabel: {\n    paddingTop: '3px',\n    color: '#EE9C34'\n  },\n  input: {\n    border: '0',\n    padding: '0 0 0 7px',\n    margin: '0',\n    flexGrow: '100',\n    width: '100%',\n    height: '22px',\n    background: 'transparent',\n    fontSize: '15px',\n    color: '#F0BF81',\n    fontFamily: 'monospace',\n    outline: 'none' // Fix for outline showing up on some browsers\n  }\n}\n","import PropTypes from 'prop-types'\n\nconst styleTypes = {\n  style: PropTypes.object,\n  contentStyle: PropTypes.object,\n  inputAreaStyle: PropTypes.object,\n  promptLabelStyle: PropTypes.object,\n  inputStyle: PropTypes.object\n}\n\nconst classNameTypes = {\n  className: PropTypes.string,\n  contentClassName: PropTypes.string,\n  inputAreaClassName: PropTypes.string,\n  promptLabelClassName: PropTypes.string,\n  inputClassName: PropTypes.string\n}\n\nconst optionTypes = {\n  autoFocus: PropTypes.bool,\n  dangerMode: PropTypes.bool,\n  disabled: PropTypes.bool,\n  disableOnProcess: PropTypes.bool,\n  ignoreCommandCase: PropTypes.bool,\n  noDefaults: PropTypes.bool,\n  noEchoBack: PropTypes.bool,\n  noHistory: PropTypes.bool,\n  noAutoScroll: PropTypes.bool,\n  noNewlineParsing: PropTypes.bool\n}\n\nconst labelTypes = {\n  welcomeMessage: PropTypes.oneOfType([\n    PropTypes.bool,\n    PropTypes.arrayOf(PropTypes.string),\n    PropTypes.string\n  ]),\n  promptLabel: PropTypes.node,\n  errorText: PropTypes.string\n}\n\nconst commandTypes = {\n  // commands: PropTypes.object.isRequired, // Cannot validate beyond this because names are dynamic\n  // commandCallback: PropTypes.func\n  runCommand: PropTypes.func.isRequired\n}\n\nconst messageTypes = {\n  messageStyle: PropTypes.object,\n  messageClassName: PropTypes.string\n}\n\nexport default {\n  ...styleTypes,\n  ...classNameTypes,\n  ...optionTypes,\n  ...labelTypes,\n  ...commandTypes,\n  ...messageTypes\n}\n","/* eslint-disable */\nimport React, { Component } from 'react'\nimport defaults from 'defaults'\nimport isEqual from 'react-fast-compare'\n\n// Components\nimport TerminalMessage from './TerminalMessage'\n\n// Handlers\nimport validateCommands from './handlers/validateCommands'\nimport scrollHistory from './handlers/scrollHistory'\nimport parseEOL from './handlers/parseEOL'\n\n// Definitions\nimport sourceStyles from './defs/styles/Terminal'\nimport types from './defs/types/Terminal'\n\n// Utils\nimport commandExists from './utils/commandExists'\n\nexport default class Terminal extends Component {\n  constructor (props) {\n    super(props)\n    this.state = {\n      stdout: [],\n      history: [],\n      historyPosition: null,\n      previousHistoryPosition: null,\n      // TODO: Add prop-controlled enable/disable on the input\n      processing: false\n    }\n\n    this.terminalRoot = React.createRef()\n    this.terminalInput = React.createRef()\n  }\n\n  static propTypes = types\n\n  /* istanbul ignore next: Covered by interactivity tests */\n  focusTerminal = () => {\n    // Only focus the terminal if text isn't being copied\n    const isTextSelected = window.getSelection().type === 'Range'\n    if (!isTextSelected) this.terminalInput.current.focus()\n  }\n\n  /* istanbul ignore next: Covered by interactivity tests */\n  scrollToBottom = () => {\n    const rootNode = this.terminalRoot.current\n\n    // This may look ridiculous, but it is necessary to decouple execution for just a millisecond in order to scroll all the way\n    setTimeout(() => { rootNode.scrollTop = rootNode.scrollHeight }, 1)\n  }\n\n  showWelcomeMessage = () => {\n    const msg = this.props.welcomeMessage\n    this.pushToStdout(msg)\n  }\n\n  /**\n   * @param {String} message\n   * @param {Object} options {\n   *  rawInput: Raw input from the terminal (For history),\n   *  isEcho: For distinguishing echo messages (Exemption from message styling)\n   * }\n   */\n  pushToStdout = (message, options) => {\n    const { stdout } = this.state\n    stdout.push({ message, isEcho: options?.isEcho || false })\n\n    /* istanbul ignore next: Covered by interactivity tests */\n    if (options?.rawInput) this.pushToHistory(options.rawInput)\n    this.setState({ stdout: stdout })\n  }\n\n  /**\n   * @param {String} rawInput Raw command input from the terminal\n   */\n  /* istanbul ignore next: Covered by interactivity tests */\n  pushToHistory = rawInput => {\n    const { history } = this.state\n    history.push(rawInput)\n    this.setState({ history: history, historyPosition: null })\n  }\n\n  getStdout = () => {\n    // Parse EOL if it isn't disabled\n    const stdout = !this.props.noNewlineParsing ? parseEOL(this.state.stdout) : this.state.stdout\n\n    return stdout.map((line, i) => {\n      return <TerminalMessage\n        key={i}\n        content={line.message}\n        dangerMode={this.props.dangerMode}\n        className={!line.isEcho ? this.props.messageClassName : /* istanbul ignore next: Covered by interactivity tests */ undefined}\n        style={!line.isEcho ? this.props.messageStyle : /* istanbul ignore next: Covered by interactivity tests */ undefined}\n      />\n    })\n  }\n\n  /* istanbul ignore next: Covered by interactivity tests */\n  clearStdout = () => {\n    this.setState({ stdout: [] })\n  }\n\n  /* istanbul ignore next: Covered by interactivity tests */\n  clearInput = () => {\n    this.setState({ historyPosition: null })\n    this.terminalInput.current.value = ''\n  }\n\n  /* istanbul ignore next: Covered by interactivity tests */\n  processCommand = () => {\n    this.setState({ processing: true }, () => {\n      // Initialise command result object\n      const rawInput = this.terminalInput.current.value\n\n      if (!this.props.noHistory) this.pushToHistory(rawInput)\n\n      if (!this.props.noEchoBack) {\n        // Mimic native terminal by echoing command back\n        // Also exempt it from message since it should not really be a message despite behaving like one\n        // Containing it in a span to allow JSX values in the prompt label\n        const echo = <span>{this.props.promptLabel || '$'} {rawInput}</span>\n        this.pushToStdout(echo, { isEcho: true })\n      }\n\n      if (rawInput) {\n        const res = this.props.runCommand(rawInput);\n        if (res)\n          this.pushToStdout(res);\n      }\n\n      this.setState({ processing: false }, () => {\n        this.clearInput()\n        if (!this.props.noAutoScroll) this.scrollToBottom()\n      })\n    })\n  }\n\n  /* istanbul ignore next: Covered by interactivity tests */\n  scrollHistory = direction => {\n    const { history, historyPosition, previousHistoryPosition } = this.state\n\n    const toUpdate = scrollHistory(direction, {\n      history,\n      historyPosition,\n      previousHistoryPosition,\n      terminalInput: this.terminalInput\n    })\n\n    // Only update if there is something to update\n    if (toUpdate) this.setState(toUpdate)\n  }\n\n  /* istanbul ignore next: Covered by interactivity tests */\n  handleInput = event => {\n    switch (event.key) {\n      case 'Enter': this.processCommand(); break\n      case 'ArrowUp': this.scrollHistory('up'); break\n      case 'ArrowDown': this.scrollHistory('down'); break\n      default:\n        // Ctrl + L\n        if (event.ctrlKey && event.keyCode === 76) {\n          this.clearStdout();\n          event.preventDefault();\n        }\n    }\n  }\n\n  // componentDidUpdate (prevProps) {\n    // If there was a change in commands, re-validate\n    // if (!isEqual(prevProps.commands, this.props.commands)) this.validateCommands()\n  // }\n\n  componentDidMount () {\n    // this.validateCommands()\n    if (this.props.welcomeMessage) this.showWelcomeMessage()\n    /* istanbul ignore next: Covered by interactivity tests */\n    if (this.props.autoFocus) this.focusTerminal()\n  }\n\n  render () {\n    const styles = {\n      container: defaults(this.props.style, sourceStyles.container),\n      content: defaults(this.props.contentStyle, sourceStyles.content),\n      inputArea: defaults(this.props.inputAreaStyle, sourceStyles.inputArea),\n      promptLabel: defaults(this.props.promptLabelStyle, sourceStyles.promptLabel),\n      input: defaults(this.props.inputStyle, sourceStyles.input)\n    }\n\n    return (\n      <div\n        ref={this.terminalRoot}\n        name='react-console-emulator'\n        className={this.props.className}\n        style={styles.container}\n        onClick={this.focusTerminal}\n      >\n        {/* Content */}\n        <div\n          name='react-console-emulator__content'\n          className={this.props.contentClassName}\n          style={styles.content}\n        >\n          {/* Stdout */}\n          {this.getStdout()}\n          {/* Input area */}\n          <div\n            name='react-console-emulator__inputArea'\n            className={this.props.inputAreaClassName}\n            style={styles.inputArea}\n          >\n            {/* Prompt label */}\n            <span\n              name='react-console-emulator__promptLabel'\n              className={this.props.promptLabelClassName}\n              style={styles.promptLabel}\n            >\n              {this.props.promptLabel || '$'}\n            </span>\n            {/* Input */}\n            <input\n              ref={this.terminalInput}\n              name='react-console-emulator__input'\n              className={this.props.inputClassName}\n              style={styles.input}\n              onKeyDown={this.handleInput}\n              type='text'\n              autoComplete='off'\n              disabled={\n                this.props.disabled ||\n                (this.props.disableOnProcess && /* istanbul ignore next: Covered by interactivity tests */ this.state.processing)\n              }\n            />\n          </div>\n        </div>\n      </div>\n    )\n  }\n}\n","import innerText from 'react-innertext'\n\nexport default stdout => {\n  const parsedStdout = []\n\n  for (let i = 0; i < stdout.length; i++) {\n    const currentLine = stdout[i]\n    const { message, isEcho } = currentLine\n\n    const messageText = innerText(message)\n\n    // Do not parse echoes (Raw inputs)\n    const parsed = !isEcho && /\\\\n/g.test(messageText) ? messageText.split(/\\\\n/g) : [messageText]\n\n    for (const line of parsed) {\n      parsedStdout.push({ message: line, isEcho: currentLine.isEcho })\n    }\n  }\n\n  return parsedStdout\n}\n","import React from 'react';\nimport Terminal from '../../react-console-emulator/Terminal';\nimport InterpContext from '../../contexts/Interpreter';\n\n// Creates the repl\n// Uses InterpContext.eval to evaluate messages\n// Use the ref.pushToStdout method to asynchronously add to the output\nconst Repl = React.forwardRef((_props, ref) => {\n  const interp = React.useContext(InterpContext);\n  const terminalRef = React.useRef();\n  React.useImperativeHandle(ref, () => ({\n    pushToStdout: str => {\n      str.split('\\n').forEach(terminalRef.current.pushToStdout);\n    },\n    clearStdout: terminalRef.current.clearStdout\n  }));\n\n  const welcome = `\n    Welcome to ${interp.name}!\n    Use Ctrl+L to clear the terminal screen\n  `;\n\n  return (\n    <Terminal\n      welcomeMessage={welcome}\n      promptLabel=\">\"\n      autoFocus={true}\n      noDefaults={true}\n      runCommand={interp.eval}\n      noNewlineParsing={true}\n      ref={terminalRef}\n    />\n  );\n});\n\nRepl.propTypes = {\n};\n\nexport default Repl;\n\n","/* eslint-disable */\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Author: Koh Zi Han, based on implementation by Koh Zi Chun\n */\n\nimport CodeMirror from 'codemirror';\n\nCodeMirror.defineMode(\"uscheme\", function () {\n    var BUILTIN = \"builtin\", COMMENT = \"comment\", STRING = \"string\",\n        ATOM = \"atom\", NUMBER = \"number\", BRACKET = \"bracket\";\n    var INDENT_WORD_SKIP = 2;\n\n    function makeKeywords(str) {\n        var obj = {}, words = str.split(\" \");\n        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n        return obj;\n    }\n\n  // var keywords = makeKeywords(\"Î» case-lambda call/cc class define-class exit-handler field import inherit\n  // init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename\n  // require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin\n  // call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax\n  // delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules\n  // abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file\n  // call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=?\n  // char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case?\n  // char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons\n  // cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact?\n  // exp expt #f floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment\n  // lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular\n  // make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string\n  // number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure?\n  // quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round\n  // scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol\n  // string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length\n  // string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol?\n  // #t tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref\n  // vector-set! with-input-from-file with-output-to-file write write-char zero?\");\n  var keywords = makeKeywords(\"define let letrec let* lambda if val + - * / < > = null? boolean? number? symbol? pair? function? cons car cdr println print printu hash error caar cadr cdar cddr caaar caadr cadar caddr cdaar cdadr cddar cdddr caaaar caaadr caadar caaddr cadaar cadadr caddar cadddr cdaaar cdaadr cdadar cdaddr cddaar cddadr cdddar cddddr list1 list2 list3 append reverse and or not atom? equal? o filter map app exists? all? foldr foldl newline space semicolon quotemark <= >= != max min negated mod gcd lcm list4 list5 list6 list7 list8\");\n    var indentKeys = makeKeywords(\"define let letrec let* lambda val\");\n\n    function stateStack(indent, type, prev) { // represents a state stack object\n        this.indent = indent;\n        this.type = type;\n        this.prev = prev;\n    }\n\n    function pushStack(state, indent, type) {\n        state.indentStack = new stateStack(indent, type, state.indentStack);\n    }\n\n    function popStack(state) {\n        state.indentStack = state.indentStack.prev;\n    }\n\n    var binaryMatcher = new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\\/[01]+#*)?i|[-+]?[01]+#*(?:\\/[01]+#*)?@[-+]?[01]+#*(?:\\/[01]+#*)?|[-+]?[01]+#*(?:\\/[01]+#*)?[-+](?:[01]+#*(?:\\/[01]+#*)?)?i|[-+]?[01]+#*(?:\\/[01]+#*)?)(?=[()\\s;\"]|$)/i);\n    var octalMatcher = new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\\/[0-7]+#*)?|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\\/[0-7]+#*)?)(?=[()\\s;\"]|$)/i);\n    var hexMatcher = new RegExp(/^(?:[-+]i|[-+][\\da-f]+#*(?:\\/[\\da-f]+#*)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?@[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?[-+](?:[\\da-f]+#*(?:\\/[\\da-f]+#*)?)?i|[-+]?[\\da-f]+#*(?:\\/[\\da-f]+#*)?)(?=[()\\s;\"]|$)/i);\n    var decimalMatcher = new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)i|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)@[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)|[-+]?(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)[-+](?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*)?i|(?:(?:(?:\\d+#+\\.?#*|\\d+\\.\\d*#*|\\.\\d+#*|\\d+)(?:[esfdl][-+]?\\d+)?)|\\d+#*\\/\\d+#*))(?=[()\\s;\"]|$)/i);\n\n    function isBinaryNumber (stream) {\n        return stream.match(binaryMatcher);\n    }\n\n    function isOctalNumber (stream) {\n        return stream.match(octalMatcher);\n    }\n\n    function isDecimalNumber (stream, backup) {\n        if (backup === true) {\n            stream.backUp(1);\n        }\n        return stream.match(decimalMatcher);\n    }\n\n    function isHexNumber (stream) {\n        return stream.match(hexMatcher);\n    }\n\n    return {\n        startState: function () {\n            return {\n                indentStack: null,\n                indentation: 0,\n                mode: false,\n                sExprComment: false,\n                sExprQuote: false\n            };\n        },\n\n        token: function (stream, state) {\n            if (state.indentStack == null && stream.sol()) {\n                // update indentation, but only if indentStack is empty\n                state.indentation = stream.indentation();\n            }\n\n            // skip spaces\n            if (stream.eatSpace()) {\n                return null;\n            }\n            var returnType = null;\n\n            switch(state.mode){\n                case \"string\": // multi-line string parsing mode\n                    var next, escaped = false;\n                    while ((next = stream.next()) != null) {\n                        if (next == \"\\\"\" && !escaped) {\n\n                            state.mode = false;\n                            break;\n                        }\n                        escaped = !escaped && next == \"\\\\\";\n                    }\n                    returnType = STRING; // continue on in scheme-string mode\n                    break;\n                case \"comment\": // comment parsing mode\n                    var next, maybeEnd = false;\n                    while ((next = stream.next()) != null) {\n                        if (next == \"#\" && maybeEnd) {\n\n                            state.mode = false;\n                            break;\n                        }\n                        maybeEnd = (next == \"|\");\n                    }\n                    returnType = COMMENT;\n                    break;\n                case \"s-expr-comment\": // s-expr commenting mode\n                    state.mode = false;\n                    if(stream.peek() == \"(\" || stream.peek() == \"[\"){\n                        // actually start scheme s-expr commenting mode\n                        state.sExprComment = 0;\n                    }else{\n                        // if not we just comment the entire of the next token\n                        stream.eatWhile(/[^\\s\\(\\)\\[\\]]/); // eat symbol atom\n                        returnType = COMMENT;\n                        break;\n                    }\n                default: // default parsing mode\n                    var ch = stream.next();\n\n                    if (ch == \"\\\"\") {\n                        state.mode = \"string\";\n                        returnType = STRING;\n\n                    } else if (ch == \"'\") {\n                        if (stream.peek() == \"(\" || stream.peek() == \"[\"){\n                            if (typeof state.sExprQuote != \"number\") {\n                                state.sExprQuote = 0;\n                            } // else already in a quoted expression\n                            returnType = ATOM;\n                        } else {\n                            stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n                            returnType = ATOM;\n                        }\n                    } else if (ch == '#') {\n                        if (stream.eat(\"|\")) {                    // Multi-line comment\n                            state.mode = \"comment\"; // toggle to comment mode\n                            returnType = COMMENT;\n                        } else if (stream.eat(/[tf]/i)) {            // #t/#f (atom)\n                            returnType = ATOM;\n                        } else if (stream.eat(';')) {                // S-Expr comment\n                            state.mode = \"s-expr-comment\";\n                            returnType = COMMENT;\n                        } else {\n                            var numTest = null, hasExactness = false, hasRadix = true;\n                            if (stream.eat(/[ei]/i)) {\n                                hasExactness = true;\n                            } else {\n                                stream.backUp(1);       // must be radix specifier\n                            }\n                            if (stream.match(/^#b/i)) {\n                                numTest = isBinaryNumber;\n                            } else if (stream.match(/^#o/i)) {\n                                numTest = isOctalNumber;\n                            } else if (stream.match(/^#x/i)) {\n                                numTest = isHexNumber;\n                            } else if (stream.match(/^#d/i)) {\n                                numTest = isDecimalNumber;\n                            } else if (stream.match(/^[-+0-9.]/, false)) {\n                                hasRadix = false;\n                                numTest = isDecimalNumber;\n                            // re-consume the intial # if all matches failed\n                            } else if (!hasExactness) {\n                                stream.eat('#');\n                            }\n                            if (numTest != null) {\n                                if (hasRadix && !hasExactness) {\n                                    // consume optional exactness after radix\n                                    stream.match(/^#[ei]/i);\n                                }\n                                if (numTest(stream))\n                                    returnType = NUMBER;\n                            }\n                        }\n                    } else if (/^[-+0-9.]/.test(ch) && isDecimalNumber(stream, true)) { // match non-prefixed number, must be decimal\n                        returnType = NUMBER;\n                    } else if (ch == \";\") { // comment\n                        stream.skipToEnd(); // rest of the line is a comment\n                        returnType = COMMENT;\n                    } else if (ch == \"(\" || ch == \"[\") {\n                      var keyWord = ''; var indentTemp = stream.column(), letter;\n                        /**\n                        Either\n                        (indent-word ..\n                        (non-indent-word ..\n                        (;something else, bracket, etc.\n                        */\n\n                        while ((letter = stream.eat(/[^\\s\\(\\[\\;\\)\\]]/)) != null) {\n                            keyWord += letter;\n                        }\n\n                        if (keyWord.length > 0 && indentKeys.propertyIsEnumerable(keyWord)) { // indent-word\n\n                            pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);\n                        } else { // non-indent word\n                            // we continue eating the spaces\n                            stream.eatSpace();\n                            if (stream.eol() || stream.peek() == \";\") {\n                                // nothing significant after\n                                // we restart indentation 1 space after\n                                pushStack(state, indentTemp + 1, ch);\n                            } else {\n                                pushStack(state, indentTemp + stream.current().length, ch); // else we match\n                            }\n                        }\n                        stream.backUp(stream.current().length - 1); // undo all the eating\n\n                        if(typeof state.sExprComment == \"number\") state.sExprComment++;\n                        if(typeof state.sExprQuote == \"number\") state.sExprQuote++;\n\n                        returnType = BRACKET;\n                    } else if (ch == \")\" || ch == \"]\") {\n                        returnType = BRACKET;\n                        if (state.indentStack != null && state.indentStack.type == (ch == \")\" ? \"(\" : \"[\")) {\n                            popStack(state);\n\n                            if(typeof state.sExprComment == \"number\"){\n                                if(--state.sExprComment == 0){\n                                    returnType = COMMENT; // final closing bracket\n                                    state.sExprComment = false; // turn off s-expr commenting mode\n                                }\n                            }\n                            if(typeof state.sExprQuote == \"number\"){\n                                if(--state.sExprQuote == 0){\n                                    returnType = ATOM; // final closing bracket\n                                    state.sExprQuote = false; // turn off s-expr quote mode\n                                }\n                            }\n                        }\n                    } else {\n                        stream.eatWhile(/[\\w_\\-!$%&*+\\.\\/:<=>?@\\^~]/);\n\n                        if (keywords && keywords.propertyIsEnumerable(stream.current())) {\n                            returnType = BUILTIN;\n                        } else returnType = \"variable\";\n                    }\n            }\n            return (typeof state.sExprComment == \"number\") ? COMMENT : ((typeof state.sExprQuote == \"number\") ? ATOM : returnType);\n        },\n\n        indent: function (state) {\n            if (state.indentStack == null) return state.indentation;\n            return state.indentStack.indent;\n        },\n\n        closeBrackets: {pairs: \"()[]{}\\\"\\\"\"},\n        lineComment: \";;\"\n    };\n});\n\nCodeMirror.defineMIME(\"text/x-scheme\", \"scheme\");\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport InterpContext from '../../contexts/Interpreter';\nimport { Controlled as CodeMirror } from 'react-codemirror2';\nimport 'codemirror/lib/codemirror.css';\nimport 'codemirror/theme/gruvbox-dark.css';\nimport 'codemirror/addon/edit/matchbrackets';\nimport 'codemirror/addon/edit/closebrackets';\nimport 'codemirror/addon/comment/comment';\nimport './uscheme-mode';\n// import 'codemirror/mode/scheme/scheme';\n\nconst Editor = ({ onCtrlEnter, value, onEdit }) => {\n\n  const [instance, setInstance] = React.useState(null);\n  const { mode, autoCloseBrackets } = React.useContext(InterpContext);\n\n  // Setup the key bindings\n  React.useEffect(() => {\n    // Edit for more keybindings\n    const keyMap = {\n      'Ctrl-/': cm => cm.toggleComment(),\n      'Ctrl-Enter': cm => onCtrlEnter(cm)\n    };\n    if (instance)\n      instance.addKeyMap(keyMap);\n  }, [instance, onCtrlEnter]);\n\n  const options = {\n    mode: mode,\n    theme: 'gruvbox-dark',\n    smartIndent: true,\n    lineNumbers: true,\n    matchBrackets: true,\n    autoCloseBrackets: autoCloseBrackets,\n  };\n\n  return (\n    <CodeMirror\n      value={value}\n      onBeforeChange={(_editor, _data, value) => onEdit(value)}\n      options={options}\n      editorDidMount={editor => setInstance(editor)}\n    />\n  );\n};\n\nEditor.propTypes = {\n  onCtrlEnter: PropTypes.func.isRequired,\n  value: PropTypes.string.isRequired,\n  onEdit: PropTypes.func.isRequired\n};\n\nexport default Editor;\n\n","\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport Container from 'react-bootstrap/Container';\nimport Row from 'react-bootstrap/Row';\nimport Col from 'react-bootstrap/Col';\n// import Col from 'react-bootstrap/Col';\nimport Button from 'react-bootstrap/Button';\nimport ListGroup from 'react-bootstrap/ListGroup';\nimport Form from 'react-bootstrap/Form';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faFolderPlus } from '@fortawesome/free-solid-svg-icons';\n\nconst FileManager = ({ usemap, onAddFile, onFileSelect }) => {\n  const [invalid, setInvalid] = React.useState(false);\n  const formRef = React.useRef(null);\n  const formSubmit = e => {\n    e.preventDefault();\n    const filename = formRef.current.value;\n    if (filename === '')\n      return;\n    if (usemap.has(filename)) {\n      setInvalid(true);\n      return;\n    };\n    onAddFile(filename);\n  };\n  return (\n    <Container>\n      <Row>\n        <p>Files</p>\n      </Row>\n      <Row>\n        <Form onSubmit={formSubmit}>\n          <Form.Row>\n            <Col>\n              <Form.Control\n                ref={formRef}\n                type=\"text\"\n                placeholder=\"Enter filename\"\n                isInvalid={invalid}\n              />\n            </Col>\n            <Col>\n              <Button onClick={formSubmit}>\n                <FontAwesomeIcon icon={faFolderPlus} />\n              </Button>\n            </Col>\n          </Form.Row>\n        </Form>\n      </Row>\n      <Row>\n        <ListGroup>\n          {Array.from(usemap).map(([file, _contents], i) => (\n            <ListGroup.Item key={i} action onClick={() => onFileSelect && onFileSelect(file)}>\n              {file}\n            </ListGroup.Item>\n          ))}\n        </ListGroup>\n      </Row>\n    </Container>\n  );\n};\n\nFileManager.propTypes = {\n  usemap: PropTypes.instanceOf(Map).isRequired,\n  onAddFile: PropTypes.func.isRequired,\n  onFileSelect: PropTypes.func\n};\n\nexport default FileManager;\n\n","\nimport React from 'react';\nimport { Nav, Navbar, Container, Row, Col } from 'react-bootstrap';\n// import Repl from './components/Repl';\n// import Editor from './components/Editor';\nimport InterpContext from './contexts/Interpreter';\n// import FileManager from './components/FileManager';\n// import { useLocalStorage } from './util';\n\nimport Repl from './components/view/Repl';\nimport Editor from './components/view/Editor';\nimport FileManager from './components/view/FileManager';\nimport { useUschemeInterpreter } from './interpreters/uscheme';\n\nconst initialFile = `\n;; main.scm\n;;\n;; Quick Tutorial:\n;;   Enter code here\n;;   Hit Ctrl+Enter to run current file\n;;   Add files/switch between files on the left\n;;   Running a file resets the environment,\n;;     to use multiple files use 'use'\n;;   Save your work! The 'main.scm' file does NOT persist!\n;;   Have fun and don't cause infinite 'use' loops!\n`;\n\nconst storageItem = 'usemap1';\n\nexport default () => {\n  const [usemap, setUsemap] = React.useState(() => {\n    let m = window.localStorage.getItem(storageItem);\n    console.log(`m = ${m}`)\n    if (m)\n      m = new Map(Object.entries(JSON.parse(m)));\n    else\n      m = new Map();\n    console.log(`m = ${m}`)\n    const urlParams = new URLSearchParams(window.location.search);\n    const content = urlParams.get('initialContent');\n    return new Map([...m, ['main.scm', content || initialFile]]);\n  });\n  React.useEffect(() => {\n    window.localStorage.setItem(storageItem, JSON.stringify(Object.fromEntries(usemap.entries())));\n  }, [usemap]);\n\n  const replRef = React.useRef(null);\n  const [currentFile, setCurrentFile] = React.useState('main.scm');\n\n  const value = usemap.get(currentFile);\n  const setValue = x => setUsemap((new Map(usemap)).set(currentFile, x));;\n  const interp = useUschemeInterpreter(usemap);\n  const run = () =>\n    replRef.current && replRef.current.pushToStdout(interp.resetEval(value));\n\n  const onAddFile = filename => {\n    setUsemap((new Map(usemap)).set(filename, `;; ${filename}\\n;; Enter code here`));\n  };\n  // React.useEffect(() => {\n    // setTimeout(() => replRef.current && replRef.current.pushToStdout('Hello'), 1000);\n    // setTimeout(() => replRef.current && replRef.current.pushToStdout('Hello'), 2000);\n    // setTimeout(() => replRef.current && replRef.current.pushToStdout('Hello'), 3000);\n  // }, []);\n  return (\n    <React.Fragment>\n      <Navbar bg=\"light\" expand=\"lg\">\n        <Navbar.Brand>Comp 105</Navbar.Brand>\n        <Nav>\n          <Container>\n          </Container>\n        </Nav>\n      </Navbar>\n        <Row>\n          <Col xs={2}>\n            <FileManager\n              usemap={usemap}\n              onAddFile={onAddFile}\n              onFileSelect={setCurrentFile}\n            />\n          </Col>\n          <Col>\n            <Container>\n              <InterpContext.Provider value={interp}>\n                <Row>\n                  <Col>\n                    <Editor value={value} onEdit={setValue} onCtrlEnter={run} />\n                  </Col>\n                  <Col>\n                    <Repl ref={replRef} />\n                  </Col>\n                </Row>\n              </InterpContext.Provider>\n            </Container>\n          </Col>\n        </Row>\n    </React.Fragment>\n  );\n};\n\n\n/* export default () => {\n  const [interpEval, setInterpEval] = React.useState(window.uscheme.make_interp);\n  // const [usemap, setUsemap] = useLocalStorage('usemap', () => new Map([['main.scm', ';; Main.scm']]));\n  const [usemap, setUsemap] = React.useState(() => new Map([['main.scm', ';; Main.scm']]));\n  const usemapFun = filename => {\n    if (usemap.has(filename)) {\n      return usemap.get(filename);\n    } else {\n      return '\\0';\n    }\n  }\n  const replRef = React.useRef();\n  const editorRef = React.useRef('');\n  const interp = {\n    eval: str => {\n      const res = interpEval([usemapFun, str]);\n      res.split('\\n').forEach(replRef.current.pushToStdout);\n    },\n    reset: str => {\n      const newEval = window.uscheme.make_interp();\n      setInterpEval(() => newEval);\n      const res = newEval([usemapFun, str]);\n      res.split('\\n').forEach(line => replRef.current.pushToStdout(line));\n    },\n    name: 'uscheme'\n  };\n  const run = () => {\n    interp.reset(editorRef.current);\n  }\n  return (\n    <React.Fragment>\n      <Navbar bg=\"light\" expand=\"lg\">\n        <Navbar.Brand>Comp 105</Navbar.Brand>\n        <Nav>\n          <Container>\n            <Nav.Link className=\"bg-success\" href=\"#\" onSelect={run}>Run</Nav.Link>\n          </Container>\n        </Nav>\n      </Navbar>\n      <Container>\n        <InterpContext.Provider value={interp}>\n          <Row>\n            <Col md=\"auto\">\n              <FileManager usemap={usemap} setUsemap={setUsemap} />\n            </Col>\n            <Col>\n              <Editor valRef={editorRef} onCtrlEnter={run} />\n            </Col>\n            <Col>\n              <Repl ref={replRef} />\n            </Col>\n          </Row>\n        </InterpContext.Provider>\n      </Container>\n    </React.Fragment>\n  );\n}; */\n\n","\nimport React from 'react';\n\nexport const useUschemeInterpreter = (filemap) => {\n\n  const [interpEval, setInterpEval] =\n    React.useState(() => window.uscheme.make_interp());\n\n  const usefn = filename => {\n    if (filemap.has(filename))\n      return filemap.get(filename);\n    return '\\0';\n  };\n\n  return {\n    eval: str => interpEval([usefn, str]),\n    resetEval: str => {\n      const newEval = window.uscheme.make_interp();\n      setInterpEval(() => newEval);\n      return newEval([usefn, str]);\n    },\n    name: 'uscheme',\n    mode: 'uscheme',\n    autoCloseBrackets: '()[]{}'\n  };\n\n};\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}